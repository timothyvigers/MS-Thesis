---
title: "MS Thesis Work"
author: "Tim Vigers"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,dpi = 600)
knitr::opts_knit$set(root.dir = "/Users/timvigers/Documents/GitHub/MS-Thesis")
library(tidyverse)
library(patchwork)
library(DiagrammeR)
library(knitr)
library(bnlearn)
library(rjags)
```

```{r load datasets}
load("./data/networks/pair_data.Rdata")
load("./data/networks/cits.Rdata")
cits = cits[!(duplicated(cits[,c("methyl","metab")])),]
load("./data/networks/subset_mcmc_perms.Rdata")
subset_perms <- all_perms
load("./data/networks/all_mcmc_perms.Rdata")
load("./data/networks/pair_list.Rdata")
load("./data/networks/bnlearn_discretized.Rdata")
load("./data/networks/bnlearn_cit_discretized.Rdata")
load("./data/networks/all_mcmc_perms_methyl_scaled.Rdata")
source("./code/networks/network_structures.R")
```

# Bayesian networks with JAGS

## Network structures and models

### Structure

```{r eval=FALSE}
ndf <-
  create_node_df(
    n = 3,
    label = c("Methylation","Metabolite","T1D Status"),
    shape = c("oval", "oval","oval"),
    fixedsize=F
  )
edf1 <-
  create_edge_df(
    from = c(2,1),
    to   = c(3,3),
    label = c("p < 0.05","p < 0.05")
  )
edf2 <-
  create_edge_df(
    from = 2,
    to   = 1,
    label = c("p < 0.001"),
    dir = "none"
  )
graph <-
  create_graph(
    nodes_df = ndf,
    edges_df = combine_edfs(edf1,edf2)
  )
graph %>% render_graph(layout = "kk",as_svg = T)
```

### Models

$$
\text{T1D | Metabolite} \sim \text{Bern}(\text{logit}(\alpha_0 + \alpha_1*\text{Metabolite}))\\
\text{Methylation | Metabolite, T1D} \sim \text{N}(\delta+\gamma*\text{Metabolite}+\beta*\text{T1D},\sigma^2)\\
$$

### Priors

$$
\alpha_0 \sim \text{N}(0,100)\\
\alpha_1 \sim \text{N}(0,100)\\
\delta \sim \text{N}(0,100)\\
\gamma \sim \text{N}(0,100)\\
\beta \sim \text{N}(0,100)\\
\sigma^2 = \frac{1}{\tau}\\
\tau \sim \text{Gamma}(0.0001,0.0001)
$$

```{r eval=FALSE}
# Plot all structures with DiagrammR
l <- lapply(paste0("struct",1:24), function(x){
  net <- model2network(get(x))
  d <- as.data.frame(net$arcs)
  d[d == "methyl"] <- 1
  d[d == "metab"] <- 2
  d[d == "T1Dgroup"] <- 3
  edf <- create_edge_df(from = c(d$from),to = d$to)
  graph <- 
    create_graph(
      nodes_df = ndf,
      edges_df = edf
    )
  return(graph)
})
l[[1]] %>% render_graph(layout = "kk",as_svg = T)
l[[2]] %>% render_graph(layout = "kk",as_svg = T)
l[[3]] %>% render_graph(layout = "kk",as_svg = T)
l[[4]] %>% render_graph(layout = "kk",as_svg = T)
l[[5]] %>% render_graph(layout = "kk",as_svg = T)
l[[6]] %>% render_graph(layout = "kk",as_svg = T)
l[[7]] %>% render_graph(layout = "kk",as_svg = T)
l[[8]] %>% render_graph(layout = "kk",as_svg = T)
l[[9]] %>% render_graph(layout = "kk",as_svg = T)
l[[10]] %>% render_graph(layout = "kk",as_svg = T)
l[[11]] %>% render_graph(layout = "kk",as_svg = T)
l[[12]] %>% render_graph(layout = "kk",as_svg = T)
l[[13]] %>% render_graph(layout = "kk",as_svg = T)
l[[14]] %>% render_graph(layout = "kk",as_svg = T)
l[[15]] %>% render_graph(layout = "kk",as_svg = T)
l[[16]] %>% render_graph(layout = "kk",as_svg = T)
l[[17]] %>% render_graph(layout = "kk",as_svg = T)
l[[18]] %>% render_graph(layout = "kk",as_svg = T)
l[[19]] %>% render_graph(layout = "kk",as_svg = T)
l[[20]] %>% render_graph(layout = "kk",as_svg = T)
l[[21]] %>% render_graph(layout = "kk",as_svg = T)
l[[22]] %>% render_graph(layout = "kk",as_svg = T)
l[[23]] %>% render_graph(layout = "kk",as_svg = T)
l[[24]] %>% render_graph(layout = "kk",as_svg = T)
```

```{r message=FALSE,fig.height=12,fig.width=14}
par(mar=c(1,1,1,1))
par(mfrow=c(6,4),lty="solid")
invisible(lapply(paste0("struct",1:24), function(x){
  m <- get(x)
  m <- gsub("methyl","Methylation",m)
  m <- gsub("metab","Metabolite",m)
  m <- gsub("T1Dgroup","T1D Status",m)
  net <- model2network(m)
  graphviz.plot(net,main = sub("struct","Structure ",x),
                shape = "ellipse")
}))
```

## Model comparisons

### DIC distribution by network structure

#### Cit-selected pairs - Unscaled

```{r}
all_dics <- sapply(all_perms,"[",1)
all_dics <- t(do.call(rbind,all_dics))
# Count best structures
kable(table(unlist(lapply(as.data.frame(all_dics), function(x){
  which.min(x)
}))),caption = "Number of Pairs Where Structure Is Best")
best <- lapply(as.data.frame(all_dics),function(x){
  min <- min(x)
  best <- which(x-min <=2)
  return(best)
})
kable(table(unlist(best)),caption = "Number of Pairs Where Structure Is Best or Within 2 DIC")
# Format DIC data
t = as.data.frame(t(all_dics))
colnames(t) = paste0("struct",1:24)
# Melt for plotting
t <- t %>% pivot_longer(struct1:struct24)
t$name = as.numeric(gsub("struct","",t$name))
# Plot
ggplot(t[t$value<2000,],aes(x=factor(name),y=value)) +
  geom_boxplot() +
  xlab("Structure number") + ylab("DIC") +
  theme_bw() +
  ylim(-200,1200)
```

#### Cit-selected pairs - scaled methylation

```{r}
all_dics <- sapply(all_perms_methyl_scaled,"[",1)
all_dics <- t(do.call(rbind,all_dics))
# Count best structures
kable(table(unlist(lapply(as.data.frame(all_dics), function(x){
  which.min(x)
}))),caption = "Number of Pairs Where Structure Is Best")
best <- lapply(as.data.frame(all_dics),function(x){
  min <- min(x)
  best <- which(x-min <=2)
  return(best)
})
kable(table(unlist(best)),caption = "Number of Pairs Where Structure Is Best or Within 2 DIC")
# Format DIC data
t = as.data.frame(t(all_dics))
colnames(t) = paste0("struct",1:24)
# Melt for plotting
t <- t %>% pivot_longer(struct1:struct24)
t$name = as.numeric(gsub("struct","",t$name))
# Plot
ggplot(t[t$value<2000,],aes(x=factor(name),y=value)) +
  geom_boxplot() +
  xlab("Structure number") + ylab("DIC") +
  theme_bw() +
  ylim(-200,1200)
```

#### Non-cit pairs

```{r warning=FALSE}
# Get correct DICs (first permutation is with our data)
t <- sapply(subset_perms,"[",1)
t <- do.call(rbind,t)
t = as.data.frame(t)
colnames(t) = paste0("struct",1:24)
# Count best structures
best <- apply(t,1,function(x){
  min <- min(x)
  best <- which(x-min <=2)
  return(best)
})
kable(table(unlist(lapply(as.data.frame(t(t)), function(x){
  which.min(x)
}))),caption = "Number of Pairs Where Structure Is Best")
kable(table(unlist(best)),caption = "Number of Pairs Where Structure Is Best or Within 2 DIC")
# Melt for plotting
t <- t %>% pivot_longer(struct1:struct24)
t$name = as.numeric(gsub("struct","",t$name))
# Plot
ggplot(t,aes(x=factor(name),y=value)) +
  geom_boxplot() +
  xlab("Structure number") + ylab("DIC") +
  theme_bw() +
  ylim(-200,1200)
```

#### Non-cit pairs - scaled methylation

```{r warning=FALSE}
# Get correct DICs (first permutation is with our data)
t <- sapply(subset_mcmc_perms_methyl_scaled,"[",1)
t <- do.call(rbind,t)
t = as.data.frame(t)
colnames(t) = paste0("struct",1:24)
# Count best structures
best <- apply(t,1,function(x){
  min <- min(x)
  best <- which(x-min <=2)
  return(best)
})
kable(table(unlist(lapply(as.data.frame(t(t)), function(x){
  which.min(x)
}))),caption = "Number of Pairs Where Structure Is Best")
kable(table(unlist(best)),caption = "Number of Pairs Where Structure Is Best or Within 2 DIC")
# Melt for plotting
t <- t %>% pivot_longer(struct1:struct24)
t$name = as.numeric(gsub("struct","",t$name))
# Plot
ggplot(t,aes(x=factor(name),y=value)) +
  geom_boxplot() +
  xlab("Structure number") + ylab("DIC") +
  theme_bw() +
  ylim(-200,1200)
```

## Permutation tests

```{r,eval=FALSE}
# For the cit-selected pairs, see how often the real DIC is significantly lower 
# than the median permuted DIC
real = lapply(all_perms, function(x){
  t = t(as.data.frame(x))
  # Get DIC for non-permuted data
  real_dics = t[1,]
  # Get median permuted DICs
  t = as.data.frame(t[2:24,])
  meds = lapply(t, median)
  # Check how often the real DIC is lower than the median
  perc <- length(which(unlist(meds) - real_dics > 2)) / 24
  return(perc)
})
kable(table(unlist(real)),caption = "# of Pairs With a Given % of DIC Below Median")
# Same for non-selected pairs
permuted = lapply(subset_perms, function(x){
  t = t(as.data.frame(x))
  # Get DIC for non-permuted data
  real_dics = t[1,]
  # Get median permuted DICs
  t = as.data.frame(t[2:24,])
  meds = lapply(t, median)
  # Check how often the real DIC is lower than the median
  perc <- length(which(unlist(meds) - real_dics > 2)) / 24
  return(perc)
})
kable(table(unlist(permuted)),caption = "# of Pairs With a Given % of DIC Below Median")
```

This feels like more of a sanity check that the permutations tests are working, but I'm not sure if it answers our questions about picking the best model. 

# bnlearn with discretized variables

Continuous variables discretized into 5 intervals of equal size. Network structure learned using a hill-climbing algorithm based on AIC.

```{r}
# Count number of arcs
arcs <- lapply(all_learned, function(x){
  n <- nrow(arcs(x))
  return(n)
})
kable(table(unlist(arcs)),caption = "# of Pairs With a Given Number of Arcs")
# Number with arcs to T1D
to_t1d <- lapply(all_learned, function(x){
  a <- as.data.frame(arcs(x))
  if("T1Dgroup" %in% a$to){
    return(x)
  } else {NULL}
})
```

There are `r length(compact(to_t1d))` total pairs with at least one arc directed to T1D status, which is also a good sanity check. 

## Cit-selected pairs only

```{r}
# Count number of arcs
arcs <- lapply(cit_learned, function(x){
  n <- nrow(arcs(x))
  return(n)
})
n_table <- as.data.frame(table(unlist(arcs)))
kable(n_table,caption = "# of Pairs With a Given Number of Arcs")
# Number with arcs to T1D
to_t1d <- lapply(cit_learned, function(x){
  a <- as.data.frame(arcs(x))
  if("T1Dgroup" %in% a$to){
    return(x)
  } else {NULL}
})
# Plot 2 arcs
invisible(lapply(cit_learned, function(x){
  a <- as.data.frame(arcs(x))
  if(nrow(a) == 2){
    plot(x)
  }
}))
```

There are `r length(compact(to_t1d))` cit-selected pairs with at least one arc directed to T1D status (out of a total `r n_table$Freq[n_table$Var1 == 2]` 2-arc graphs).

If it's okay to disctretize the variables, the next step would probably be to look at how much overlap there is between the 2-arc graphs (e.g. are they all the same metabolite but 76 different methylation probes?). If there are too many nodes to put into a larger graph, we could pick based on arc strength?

## Potential problems

### DIC

- "From Bayesian perspective, DIC is not theoretically justified since it measures the fit of the model when the parameters are fixed to the posterior expectation and is not therefore an unbiased estimate of the true generalization utility." (Piironen & Vehtari, 2017)

- "The numerical experiments show that the over-fitting in the selection may be a potential problem and hinder the model selection considerably. This is the case especially when the dataset is small (high variance in the utility estimates) and the number of models under comparison large (large number of variables). Especially vulnerable methods for this type of overfitting are CV, WAIC, DIC and other methods that rely on data reuse and have therefore relatively high variance in the utility estimates." (Piironen & Vehtari, 2017)

### Priors

Tim was wrong about gamma priors causing problems. This issue is specific to logistic models with random effects, where the prior is $b_i \sim N(0,\frac{1}{\lambda})$. The Piironen paper can be a little unclear, so maybe we need a better resource.

# References

- Piironen, J., & Vehtari, A. (2017). Comparison of Bayesian predictive methods for model selection. Statistics and Computing, 27(3), 711–735. https://doi.org/10.1007/s11222-016-9649-y